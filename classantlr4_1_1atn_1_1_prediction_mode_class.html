<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AntlrExpr: antlr4::atn::PredictionModeClass类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AntlrExpr
   &#160;<span id="projectnumber">0.0.3-79cdf44</span>
   </div>
   <div id="projectbrief">AntlrExpr笔记</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceantlr4.html">antlr4</a></li><li class="navelem"><a class="el" href="namespaceantlr4_1_1atn.html">atn</a></li><li class="navelem"><a class="el" href="classantlr4_1_1atn_1_1_prediction_mode_class.html">PredictionModeClass</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="classantlr4_1_1atn_1_1_prediction_mode_class-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">antlr4::atn::PredictionModeClass类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_prediction_mode_8h_source.html">PredictionMode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:aac21971225a47c6c3ee7bc0148567d6e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1atn_1_1_prediction_mode_class.html#aac21971225a47c6c3ee7bc0148567d6e">hasSLLConflictTerminatingPrediction</a> (<a class="el" href="namespaceantlr4_1_1atn.html#ad9285036b2a01af0109507c442ea0e25">PredictionMode</a> mode, <a class="el" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html">ATNConfigSet</a> *configs)</td></tr>
<tr class="separator:aac21971225a47c6c3ee7bc0148567d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock">
<p class="definition">在文件 <a class="el" href="_prediction_mode_8h_source.html">PredictionMode.h</a> 第 <a class="el" href="_prediction_mode_8h_source.html#l00082">82</a> 行定义.</p>
</div><h2 class="groupheader">成员函数说明</h2>
<a id="aac21971225a47c6c3ee7bc0148567d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac21971225a47c6c3ee7bc0148567d6e">&#9670;&nbsp;</a></span>hasSLLConflictTerminatingPrediction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PredictionModeClass::hasSLLConflictTerminatingPrediction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceantlr4_1_1atn.html#ad9285036b2a01af0109507c442ea0e25">PredictionMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html">ATNConfigSet</a> *&#160;</td>
          <td class="paramname"><em>configs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the SLL prediction termination condition.</p>
<p>This method computes the SLL prediction termination condition for both of the following cases.</p>
<ul>
<li>
The usual SLL+LL fallback upon SLL conflict </li>
<li>
Pure SLL without LL fallback </li>
</ul>
<p><b>COMBINED SLL+LL PARSING</b></p>
<p>When LL-fallback is enabled upon SLL conflict, correct predictions are ensured regardless of how the termination condition is computed by this method. Due to the substantially higher cost of LL prediction, the prediction should only fall back to LL when the additional lookahead cannot lead to a unique SLL prediction.</p>
<p>Assuming combined SLL+LL parsing, an SLL configuration set with only conflicting subsets should fall back to full LL, even if the configuration sets don't resolve to the same alternative (e.g. </p><div class="fragment"><div class="line">{1,2} </div>
</div><!-- fragment --><p> and</p><div class="fragment"><div class="line">{3,4} </div>
</div><!-- fragment --><p> . If there is at least one non-conflicting configuration, SLL could continue with the hopes that more lookahead will resolve via one of those non-conflicting configurations.</p>
<p>Here's the prediction termination rule them: SLL (for SLL+LL parsing) stops when it sees only conflicting configuration subsets. In contrast, full LL keeps going when there is uncertainty.</p>
<p><b>HEURISTIC</b></p>
<p>As a heuristic, we stop prediction when we see any conflicting subset unless we see a state that only has one alternative associated with it. The single-alt-state thing lets prediction continue upon rules like (otherwise, it would admit defeat too soon):</p>
<div class="fragment"><div class="line">[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) <span class="charliteral">&#39;;&#39;</span> ; </div>
</div><!-- fragment --> <p>When the ATN simulation reaches the state before</p><div class="fragment"><div class="line"><span class="charliteral">&#39;;&#39;</span> </div>
</div><!-- fragment --><p> , it has a DFA state that looks like:</p><div class="fragment"><div class="line">[12|1|[], 6|2|[], 12|2|[]] </div>
</div><!-- fragment --><p> . Naturally </p><div class="fragment"><div class="line">12|1|[] </div>
</div><!-- fragment --><p> and</p><div class="fragment"><div class="line">12|2|[] </div>
</div><!-- fragment --><p> conflict, but we cannot stop processing this node because alternative to has another way to continue, via</p><div class="fragment"><div class="line">[6|2|[]] </div>
</div><!-- fragment --><p> .</p>
<p>It also let's us continue for this rule:</p>
<div class="fragment"><div class="line">[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ; </div>
</div><!-- fragment --> <p>After matching input A, we reach the stop state for rule A, state 1. State 8 is the state right before B. Clearly alternatives 1 and 2 conflict and no amount of further lookahead will separate the two. However, alternative 3 will be able to continue and so we do not stop working on this state. In the previous example, we're concerned with states associated with the conflicting alternatives. Here alt 3 is not associated with the conflicting configs, but since we can continue looking for input reasonably, don't declare the state done.</p>
<p><b>PURE SLL PARSING</b></p>
<p>To handle pure SLL parsing, all we have to do is make sure that we combine stack contexts for configurations that differ only by semantic predicate. From there, we can do the usual SLL termination heuristic.</p>
<p><b>PREDICATES IN SLL+LL PARSING</b></p>
<p>SLL decisions don't evaluate predicates until after they reach DFA stop states because they need to create the DFA cache that works in all semantic situations. In contrast, full LL evaluates predicates collected during start state computation so it can ignore predicates thereafter. This means that SLL termination detection can totally ignore semantic predicates.</p>
<p>Implementation-wise, <a class="el" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html">ATNConfigSet</a> combines stack contexts but not semantic predicate contexts so we might see two configurations like the following.</p>
<div class="fragment"><div class="line">(s, 1, x, {}), (s, 1, x<span class="stringliteral">&#39;, {p}) </span></div>
</div><!-- fragment --> <p>Before testing these configurations against others, we have to merge </p><div class="fragment"><div class="line">x </div>
</div><!-- fragment --><p> and</p><div class="fragment"><div class="line">x<span class="stringliteral">&#39; </span></div>
</div><!-- fragment --><p> (without modifying the existing configurations). For example, we test</p><div class="fragment"><div class="line">(x+x<span class="stringliteral">&#39;)==x&#39;</span><span class="stringliteral">&#39; </span></div>
</div><!-- fragment --><p> when looking for conflicts in the following configurations.</p>
<div class="fragment"><div class="line">(s, 1, x, {}), (s, 1, x<span class="stringliteral">&#39;, {p}), (s, 2, x&#39;</span><span class="stringliteral">&#39;, {}) </span></div>
</div><!-- fragment --> <p>If the configuration set has predicates (as indicated by <a class="el" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html#acf4dc336b07151064e0acdd84d5a6dcc">ATNConfigSet#hasSemanticContext</a>), this algorithm makes a copy of the configurations to strip out all of the predicates so that a standard <a class="el" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html">ATNConfigSet</a> will merge everything ignoring predicates.</p>

<p class="definition">在文件 <a class="el" href="_prediction_mode_8cpp_source.html">PredictionMode.cpp</a> 第 <a class="el" href="_prediction_mode_8cpp_source.html#l00042">42</a> 行定义.</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                                                                                        {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="comment">/* Configs in rule stop states indicate reaching the end of the decision</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">   * rule (local context) or end of start rule (full context). If all</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">   * configs meet this condition, then none of the configurations is able</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">   * to match additional input so we terminate prediction.</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <span class="keywordflow">if</span> (allConfigsInRuleStopStates(configs)) {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  }</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160; </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="keywordtype">bool</span> heuristic;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160; </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <span class="comment">// Pure SLL mode parsing or SLL+LL if:</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">// Don&#39;t bother with combining configs from different semantic</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="comment">// contexts if we can fail over to full LL; costs more time</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="comment">// since we&#39;ll often fail over anyway.</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="keywordflow">if</span> (mode == <a class="code" href="namespaceantlr4_1_1atn.html#ad9285036b2a01af0109507c442ea0e25aae2ecfbd95d475ddf08876080d57e3d9">PredictionMode::SLL</a> || !configs-&gt;<a class="code" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html#acf4dc336b07151064e0acdd84d5a6dcc">hasSemanticContext</a>) {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    std::vector&lt;antlrcpp::BitSet&gt; altsets = getConflictingAltSubsets(configs);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    heuristic = hasConflictingAltSet(altsets) &amp;&amp; !hasStateAssociatedWithOneAlt(configs);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="comment">// dup configs, tossing out semantic predicates</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <a class="code" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html">ATNConfigSet</a> dup(<span class="keyword">true</span>);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;config : configs-&gt;<a class="code" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html#a5404495afc6bb7823429d202a1625bdc">configs</a>) {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      <a class="code" href="antlr4-common_8h.html#add5e90b302c31b74a46619f240214bcc">Ref&lt;ATNConfig&gt;</a> c = std::make_shared&lt;ATNConfig&gt;(config, <a class="code" href="classantlr4_1_1atn_1_1_semantic_context.html#a1c9db994b89d06e9d8969e78050aeff5">SemanticContext::NONE</a>);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      dup.add(c);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    std::vector&lt;antlrcpp::BitSet&gt; altsets = getConflictingAltSubsets(&amp;dup);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    heuristic = hasConflictingAltSet(altsets) &amp;&amp; !hasStateAssociatedWithOneAlt(&amp;dup);</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  }</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160; </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keywordflow">return</span> heuristic;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;}</div>
</div><!-- fragment --><div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classantlr4_1_1atn_1_1_prediction_mode_class_aac21971225a47c6c3ee7bc0148567d6e_cgraph.png" border="0" usemap="#classantlr4_1_1atn_1_1_prediction_mode_class_aac21971225a47c6c3ee7bc0148567d6e_cgraph" alt=""/></div>
<map name="classantlr4_1_1atn_1_1_prediction_mode_class_aac21971225a47c6c3ee7bc0148567d6e_cgraph" id="classantlr4_1_1atn_1_1_prediction_mode_class_aac21971225a47c6c3ee7bc0148567d6e_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,241,61"/>
<area shape="rect" href="classantlr4_1_1atn_1_1_a_t_n_config_set.html#aa2fc9693c9586947a34877d179020f73" title=" " alt="" coords="289,20,507,47"/>
</map>
</div>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>runtime/atn/<a class="el" href="_prediction_mode_8h_source.html">PredictionMode.h</a></li>
<li>runtime/atn/<a class="el" href="_prediction_mode_8cpp_source.html">PredictionMode.cpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespaceantlr4_1_1atn_html_ad9285036b2a01af0109507c442ea0e25aae2ecfbd95d475ddf08876080d57e3d9"><div class="ttname"><a href="namespaceantlr4_1_1atn.html#ad9285036b2a01af0109507c442ea0e25aae2ecfbd95d475ddf08876080d57e3d9">antlr4::atn::PredictionMode::SLL</a></div><div class="ttdeci">@ SLL</div></div>
<div class="ttc" id="aclassantlr4_1_1atn_1_1_a_t_n_config_set_html_acf4dc336b07151064e0acdd84d5a6dcc"><div class="ttname"><a href="classantlr4_1_1atn_1_1_a_t_n_config_set.html#acf4dc336b07151064e0acdd84d5a6dcc">antlr4::atn::ATNConfigSet::hasSemanticContext</a></div><div class="ttdeci">bool hasSemanticContext</div><div class="ttdef"><b>Definition:</b> <a href="_a_t_n_config_set_8h_source.html#l00034">ATNConfigSet.h:34</a></div></div>
<div class="ttc" id="aclassantlr4_1_1atn_1_1_semantic_context_html_a1c9db994b89d06e9d8969e78050aeff5"><div class="ttname"><a href="classantlr4_1_1atn_1_1_semantic_context.html#a1c9db994b89d06e9d8969e78050aeff5">antlr4::atn::SemanticContext::NONE</a></div><div class="ttdeci">static const Ref&lt; SemanticContext &gt; NONE</div><div class="ttdef"><b>Definition:</b> <a href="_semantic_context_8h_source.html#l00044">SemanticContext.h:44</a></div></div>
<div class="ttc" id="aclassantlr4_1_1atn_1_1_a_t_n_config_set_html"><div class="ttname"><a href="classantlr4_1_1atn_1_1_a_t_n_config_set.html">antlr4::atn::ATNConfigSet</a></div><div class="ttdef"><b>Definition:</b> <a href="_a_t_n_config_set_8h_source.html#l00016">ATNConfigSet.h:16</a></div></div>
<div class="ttc" id="aclassantlr4_1_1atn_1_1_a_t_n_config_set_html_a5404495afc6bb7823429d202a1625bdc"><div class="ttname"><a href="classantlr4_1_1atn_1_1_a_t_n_config_set.html#a5404495afc6bb7823429d202a1625bdc">antlr4::atn::ATNConfigSet::configs</a></div><div class="ttdeci">std::vector&lt; Ref&lt; ATNConfig &gt; &gt; configs</div><div class="ttdoc">Track the elements as they are added to the set; supports get(i)</div><div class="ttdef"><b>Definition:</b> <a href="_a_t_n_config_set_8h_source.html#l00019">ATNConfigSet.h:19</a></div></div>
<div class="ttc" id="aantlr4-common_8h_html_add5e90b302c31b74a46619f240214bcc"><div class="ttname"><a href="antlr4-common_8h.html#add5e90b302c31b74a46619f240214bcc">Ref</a></div><div class="ttdeci">std::shared_ptr&lt; T &gt; Ref</div><div class="ttdef"><b>Definition:</b> <a href="antlr4-common_8h_source.html#l00139">antlr4-common.h:139</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
